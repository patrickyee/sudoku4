<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
        />
        <title>4x4 Sudoku</title>
        <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
        <style>
            body {
                font-family: Arial, sans-serif;
                display: flex;
                justify-content: center;
                align-items: center;
                min-height: 100vh;
                margin: 0;
                background-color: #f0f0f0;
                padding: 5vw;
                box-sizing: border-box;
            }

            #app {
                text-align: center;
                width: 100%;
                max-width: min(500px, 100vw - 10vw);
            }

            h1 {
                color: #333;
                font-size: clamp(24px, 6vw, 48px);
                margin: 2vh 0;
            }

            .header {
                display: flex;
                align-items: center;
                justify-content: center;
                position: relative;
                width: 100%;
            }

            .hamburger {
                position: absolute;
                left: 0;
                top: 50%;
                transform: translateY(-50%);
                background: none !important;
                border: none;
                cursor: pointer;
                padding: 10px;
                display: flex;
                flex-direction: column;
                gap: 5px;
                margin: 0;
                z-index: 10;
            }

            .hamburger:hover {
                background: none !important;
                transform: translateY(-50%) !important;
            }

            .hamburger:active {
                background: none !important;
                transform: translateY(-50%) !important;
            }

            .hamburger span {
                display: block;
                width: 30px;
                height: 3px;
                background-color: #333;
                border-radius: 2px;
                pointer-events: none;
            }

            .settings-overlay {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: rgba(0, 0, 0, 0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 1000;
            }

            .settings-modal {
                background-color: white;
                border-radius: clamp(8px, 2vw, 12px);
                padding: clamp(20px, 4vw, 30px);
                max-width: 400px;
                width: 90%;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            }

            .settings-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: clamp(20px, 4vw, 30px);
            }

            .settings-header h2 {
                margin: 0;
                font-size: clamp(20px, 4vw, 28px);
                color: #333;
            }

            .close-btn {
                background: none;
                border: none;
                font-size: 32px;
                cursor: pointer;
                color: #666;
                padding: 0;
                width: 40px;
                height: 40px;
                display: flex;
                align-items: center;
                justify-content: center;
                margin: 0;
            }

            .close-btn:hover {
                color: #333;
                background: none;
                transform: none;
            }

            .settings-item {
                margin-bottom: clamp(20px, 3vw, 25px);
                text-align: left;
            }

            .settings-item label {
                display: block;
                font-size: clamp(16px, 2.5vw, 18px);
                font-weight: bold;
                margin-bottom: clamp(8px, 1.5vw, 10px);
                color: #333;
            }

            .settings-item select {
                width: 100%;
                padding: clamp(10px, 1.5vw, 12px);
                font-size: clamp(14px, 2vw, 16px);
                border: 2px solid #ccc;
                border-radius: clamp(4px, 0.8vw, 6px);
                background-color: white;
                cursor: pointer;
            }

            .settings-item select:focus {
                outline: none;
                border-color: #4caf50;
            }

            .checkbox-item {
                display: flex;
                align-items: center;
                cursor: pointer;
            }

            .checkbox-item input {
                width: clamp(20px, 3vw, 24px);
                height: clamp(20px, 3vw, 24px);
                margin-right: clamp(10px, 1.5vw, 12px);
                cursor: pointer;
            }

            .checkbox-item span {
                font-size: clamp(16px, 2.5vw, 18px);
            }

            .grid {
                display: inline-grid;
                grid-template-columns: repeat(4, 1fr);
                gap: 0;
                margin: 3vh 0;
                outline: max(2px, 0.4vw) solid #333;
                width: min(90vw, 400px);
                max-width: 100%;
            }

            .cell {
                width: 100%;
                aspect-ratio: 1;
                background-color: white;
                border-top: max(1px, 0.2vw) solid #ccc;
                border-left: max(1px, 0.2vw) solid #ccc;
                font-size: clamp(20px, 5vw, 36px);
                text-align: center;
                box-sizing: border-box;
            }

            .cell:nth-child(n + 9):nth-child(-n + 12) {
                border-top: max(2px, 0.4vw) solid #333;
            }

            .cell:nth-child(4n + 3) {
                border-left: max(2px, 0.4vw) solid #333;
            }

            .cell input {
                width: 100%;
                height: 100%;
                border: none;
                text-align: center;
                font-size: clamp(20px, 5vw, 36px);
                outline: none;
                /* iOS Safari fixes */
                -webkit-appearance: none;
                appearance: none;
                background-color: transparent;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 0;
                margin: 0;
            }

            .cell.fixed {
                background-color: #e8e8e8;
                font-weight: bold;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .cell.error input {
                background-color: #ffcccc;
                /* Force background color on iOS Safari */
                -webkit-appearance: none;
            }

            .cell.correct input {
                background-color: #ccffcc;
                /* Force background color on iOS Safari */
                -webkit-appearance: none;
            }

            button {
                padding: clamp(12px, 2vh, 16px) clamp(16px, 4vw, 32px);
                font-size: clamp(14px, 2.5vw, 20px);
                background-color: #4caf50;
                color: white;
                border: none;
                border-radius: clamp(4px, 1vw, 8px);
                cursor: pointer;
                margin: clamp(5px, 1.5vw, 10px);
                font-weight: bold;
            }

            button:hover {
                background-color: #45a049;
            }

            button:active {
                transform: scale(0.98);
            }

            button:disabled {
                background-color: #ccc;
                cursor: not-allowed;
                opacity: 0.6;
            }

            button:disabled:hover {
                background-color: #ccc;
            }

            .message {
                margin-top: 3vh;
                font-size: clamp(16px, 3vw, 24px);
                font-weight: bold;
                min-height: clamp(30px, 5vh, 40px);
            }

            .message.success {
                color: #4caf50;
            }
        </style>
    </head>
    <body>
        <div id="app">
            <div class="header">
                <button class="hamburger" @click="openSettings">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
                <h1>{{ t.title }}</h1>
            </div>

            <div
                class="settings-overlay"
                v-if="showSettings"
                @click.self="showSettings = false"
            >
                <div class="settings-modal">
                    <div class="settings-header">
                        <h2>{{ t.settings }}</h2>
                        <button class="close-btn" @click="showSettings = false">
                            &times;
                        </button>
                    </div>
                    <div class="settings-item">
                        <label>{{ t.language }}</label>
                        <select
                            v-model="currentLanguage"
                            @change="changeLanguage"
                        >
                            <option value="zh">ÁπÅÈ´î‰∏≠Êñá</option>
                            <option value="zh-CN">ÁÆÄ‰Ωì‰∏≠Êñá</option>
                            <option value="ja">Êó•Êú¨Ë™û</option>
                            <option value="en">English</option>
                            <option value="es">Espa√±ol</option>
                        </select>
                    </div>
                    <div class="settings-item">
                        <label class="checkbox-item">
                            <input type="checkbox" v-model="showHints" />
                            <span>{{ t.showHints }}</span>
                        </label>
                    </div>
                </div>
            </div>
            <div
                style="
                    font-size: clamp(18px, 3.5vw, 28px);
                    margin: 2vh 0;
                    font-weight: bold;
                "
            >
                <div>{{ t.time }}{{ formattedTime }}</div>
                <div
                    v-if="bestTime > 0"
                    style="color: #4caf50; margin-top: 1vh"
                >
                    {{ t.bestTime }}{{ formatTime(bestTime) }}
                </div>
            </div>
            <div class="grid">
                <div
                    v-for="(cell, index) in puzzle"
                    :key="index"
                    :class="getCellClass(cell)"
                >
                    <span v-if="cell.fixed">{{ cell.value }}</span>
                    <input
                        v-else
                        type="tel"
                        inputmode="numeric"
                        pattern="[1-4]"
                        maxlength="1"
                        v-model="cell.value"
                        @focus="recordOldValue(index)"
                        @input="validateCell(index)"
                        @keypress="onlyNumbers"
                    />
                </div>
            </div>
            <div>
                <button @click="newGame">{{ t.newGame }}</button>
                <button @click="checkSolution">{{ t.checkSolution }}</button>
                <button @click="undo" :disabled="!canUndo">{{ t.undo }}</button>
            </div>
            <div class="message" :class="{ success: isComplete }">
                {{ message }}
            </div>
        </div>

        <script>
            const { createApp } = Vue;

            const translations = {
                zh: {
                    title: "4x4 Êï∏Áç®",
                    settings: "Ë®≠ÂÆö",
                    language: "Ë™ûË®Ä",
                    showHints: "È°ØÁ§∫ÊèêÁ§∫È°èËâ≤",
                    time: "ÊôÇÈñìÔºö",
                    bestTime: "ÊúÄ‰Ω≥ÊôÇÈñìÔºö",
                    newGame: "Êñ∞ÈÅäÊà≤",
                    checkSolution: "Ê™¢Êü•Á≠îÊ°à",
                    undo: "Âæ©Âéü",
                    congratsNewRecord: "üéâ ÊÅ≠ÂñúÔºÅ‰Ω†ÊàêÂäüËß£Èñã‰∫ÜÔºÅÊñ∞Á¥ÄÈåÑÔºÅ",
                    congrats: "üéâ ÊÅ≠ÂñúÔºÅ‰Ω†ÊàêÂäüËß£Èñã‰∫ÜÔºÅ",
                    keepGoing: "ÁπºÁ∫åÂä™ÂäõÔºÅË´ãÂ°´ÊªøÊâÄÊúâÊ†ºÂ≠ê„ÄÇ",
                    someIncorrect: "Êúâ‰∫õÊ†ºÂ≠ê‰∏çÊ≠£Á¢∫ÔºåÂÜçË©¶Ë©¶ÁúãÔºÅ",
                },
                "zh-CN": {
                    title: "4x4 Êï∞Áã¨",
                    settings: "ËÆæÁΩÆ",
                    language: "ËØ≠Ë®Ä",
                    showHints: "ÊòæÁ§∫ÊèêÁ§∫È¢úËâ≤",
                    time: "Êó∂Èó¥Ôºö",
                    bestTime: "ÊúÄ‰Ω≥Êó∂Èó¥Ôºö",
                    newGame: "Êñ∞Ê∏∏Êàè",
                    checkSolution: "Ê£ÄÊü•Á≠îÊ°à",
                    undo: "Êí§ÈîÄ",
                    congratsNewRecord: "üéâ ÊÅ≠ÂñúÔºÅ‰Ω†ÊàêÂäüËß£ÂºÄ‰∫ÜÔºÅÊñ∞Á∫™ÂΩïÔºÅ",
                    congrats: "üéâ ÊÅ≠ÂñúÔºÅ‰Ω†ÊàêÂäüËß£ÂºÄ‰∫ÜÔºÅ",
                    keepGoing: "ÁªßÁª≠Âä™ÂäõÔºÅËØ∑Â°´Êª°ÊâÄÊúâÊ†ºÂ≠ê„ÄÇ",
                    someIncorrect: "Êúâ‰∫õÊ†ºÂ≠ê‰∏çÊ≠£Á°ÆÔºåÂÜçËØïËØïÁúãÔºÅ",
                },
                ja: {
                    title: "4x4 Êï∞Áã¨",
                    settings: "Ë®≠ÂÆö",
                    language: "Ë®ÄË™û",
                    showHints: "„Éí„É≥„ÉàËâ≤„ÇíË°®Á§∫",
                    time: "ÊôÇÈñìÔºö",
                    bestTime: "„Éô„Çπ„Éà„Çø„Ç§„É†Ôºö",
                    newGame: "Êñ∞„Åó„ÅÑ„Ç≤„Éº„É†",
                    checkSolution: "Ëß£Á≠î„ÇíÁ¢∫Ë™ç",
                    undo: "ÂÖÉ„Å´Êàª„Åô",
                    congratsNewRecord:
                        "üéâ „Åä„ÇÅ„Åß„Å®„ÅÜ„Åî„Åñ„ÅÑ„Åæ„ÅôÔºÅËß£„Åë„Åæ„Åó„ÅüÔºÅÊñ∞Ë®òÈå≤ÔºÅ",
                    congrats: "üéâ „Åä„ÇÅ„Åß„Å®„ÅÜ„Åî„Åñ„ÅÑ„Åæ„ÅôÔºÅËß£„Åë„Åæ„Åó„ÅüÔºÅ",
                    keepGoing: "È†ëÂºµ„Å£„Å¶ÔºÅ„Åô„Åπ„Å¶„ÅÆ„Éû„Çπ„ÇíÂüã„ÇÅ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
                    someIncorrect:
                        "ÈñìÈÅï„Å£„Å¶„ÅÑ„Çã„Éû„Çπ„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ„ÇÇ„ÅÜ‰∏ÄÂ∫¶Ë©¶„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºÅ",
                },
                en: {
                    title: "4x4 Sudoku",
                    settings: "Settings",
                    language: "Language",
                    showHints: "Show Hint Colors",
                    time: "Time: ",
                    bestTime: "Best Time: ",
                    newGame: "New Game",
                    checkSolution: "Check Solution",
                    undo: "Undo",
                    congratsNewRecord:
                        "üéâ Congratulations! You solved it! New Record!",
                    congrats: "üéâ Congratulations! You solved it!",
                    keepGoing: "Keep going! Please fill all cells.",
                    someIncorrect: "Some cells are incorrect, try again!",
                },
                es: {
                    title: "4x4 Sudoku",
                    settings: "Configuraci√≥n",
                    language: "Idioma",
                    showHints: "Mostrar Colores de Ayuda",
                    time: "Tiempo: ",
                    bestTime: "Mejor Tiempo: ",
                    newGame: "Nuevo Juego",
                    checkSolution: "Verificar Soluci√≥n",
                    undo: "Deshacer",
                    congratsNewRecord:
                        "üéâ ¬°Felicidades! ¬°Lo resolviste! ¬°Nuevo R√©cord!",
                    congrats: "üéâ ¬°Felicidades! ¬°Lo resolviste!",
                    keepGoing:
                        "¬°Sigue adelante! Por favor llena todas las celdas.",
                    someIncorrect:
                        "¬°Algunas celdas son incorrectas, int√©ntalo de nuevo!",
                },
            };

            createApp({
                data() {
                    return {
                        puzzle: [],
                        solution: [],
                        message: "",
                        isComplete: false,
                        currentTime: 0,
                        timerInterval: null,
                        bestTime: 0,
                        undoHistory: [],
                        showHints: true,
                        showSettings: false,
                        currentLanguage: "zh",
                        translations: translations,
                    };
                },
                computed: {
                    formattedTime() {
                        return this.formatTime(this.currentTime);
                    },
                    canUndo() {
                        return this.undoHistory.length > 0;
                    },
                    t() {
                        return this.translations[this.currentLanguage];
                    },
                },
                mounted() {
                    const savedLanguage =
                        localStorage.getItem("sudoku-language");
                    if (savedLanguage && this.translations[savedLanguage]) {
                        this.currentLanguage = savedLanguage;
                    }
                    const savedHints = localStorage.getItem("sudoku-hints");
                    if (savedHints !== null) {
                        this.showHints = savedHints === "true";
                    }
                    this.newGame();
                },
                beforeUnmount() {
                    if (this.timerInterval) {
                        clearInterval(this.timerInterval);
                    }
                },
                watch: {
                    showHints(newVal) {
                        localStorage.setItem("sudoku-hints", newVal);
                    },
                },
                methods: {
                    openSettings() {
                        this.showSettings = true;
                    },
                    changeLanguage() {
                        localStorage.setItem(
                            "sudoku-language",
                            this.currentLanguage,
                        );
                    },
                    getCellClass(cell) {
                        return {
                            cell: true,
                            fixed: cell.fixed,
                            error: this.showHints && cell.error,
                            correct: this.showHints && cell.correct,
                        };
                    },
                    formatTime(seconds) {
                        const mins = Math.floor(seconds / 60);
                        const secs = seconds % 60;
                        return `${mins}:${secs.toString().padStart(2, "0")}`;
                    },
                    startTimer() {
                        this.currentTime = 0;
                        if (this.timerInterval) {
                            clearInterval(this.timerInterval);
                        }
                        const startTime = Date.now();
                        this.timerInterval = setInterval(() => {
                            this.currentTime = Math.floor(
                                (Date.now() - startTime) / 1000,
                            );
                        }, 1000);
                    },
                    stopTimer() {
                        if (this.timerInterval) {
                            clearInterval(this.timerInterval);
                            this.timerInterval = null;
                        }
                    },
                    handleCompletion() {
                        this.stopTimer();
                        if (
                            this.bestTime === 0 ||
                            this.currentTime < this.bestTime
                        ) {
                            this.bestTime = this.currentTime;
                            this.message = this.t.congratsNewRecord;
                        } else {
                            this.message = this.t.congrats;
                        }
                        this.isComplete = true;
                    },
                    undo() {
                        if (this.undoHistory.length === 0) return;

                        const lastMove = this.undoHistory.pop();
                        this.puzzle[lastMove.index].value = lastMove.oldValue;
                        this.puzzle[lastMove.index].error = false;
                        this.puzzle[lastMove.index].correct = false;
                    },
                    newGame() {
                        this.message = "";
                        this.isComplete = false;
                        this.undoHistory = [];
                        this.generatePuzzle();
                        this.startTimer();
                    },

                    generatePuzzle() {
                        const solutions = [
                            [1, 2, 3, 4, 3, 4, 1, 2, 2, 3, 4, 1, 4, 1, 2, 3],
                            [2, 1, 4, 3, 4, 3, 2, 1, 1, 4, 3, 2, 3, 2, 1, 4],
                            [3, 4, 1, 2, 1, 2, 3, 4, 4, 3, 2, 1, 2, 1, 4, 3],
                            [4, 3, 2, 1, 2, 1, 4, 3, 3, 2, 1, 4, 1, 4, 3, 2],
                            [1, 3, 2, 4, 4, 2, 3, 1, 3, 1, 4, 2, 2, 4, 1, 3],
                            [2, 4, 1, 3, 3, 1, 4, 2, 4, 2, 3, 1, 1, 3, 2, 4],
                            [3, 2, 4, 1, 1, 4, 2, 3, 4, 3, 1, 2, 2, 1, 3, 4],
                            [4, 1, 3, 2, 2, 3, 1, 4, 1, 4, 2, 3, 3, 2, 4, 1],
                            [1, 4, 2, 3, 3, 2, 4, 1, 4, 1, 3, 2, 2, 3, 1, 4],
                            [2, 3, 4, 1, 4, 1, 2, 3, 1, 2, 3, 4, 3, 4, 1, 2],
                            [3, 1, 4, 2, 4, 2, 1, 3, 1, 3, 2, 4, 2, 4, 3, 1],
                            [4, 2, 1, 3, 1, 3, 2, 4, 2, 4, 3, 1, 3, 1, 4, 2],
                            [1, 3, 4, 2, 2, 4, 3, 1, 4, 1, 2, 3, 3, 2, 1, 4],
                            [2, 4, 3, 1, 3, 1, 2, 4, 1, 2, 4, 3, 4, 3, 1, 2],
                            [3, 1, 2, 4, 4, 2, 1, 3, 1, 4, 3, 2, 2, 3, 4, 1],
                            [4, 2, 1, 3, 1, 3, 4, 2, 3, 4, 2, 1, 2, 1, 3, 4],
                        ];

                        this.solution =
                            solutions[
                                Math.floor(Math.random() * solutions.length)
                            ];

                        let cellsToRemove = 8;
                        let removed = new Set();
                        let attempts = 0;
                        const maxAttempts = 20;

                        while (attempts < maxAttempts) {
                            removed = new Set();
                            while (removed.size < cellsToRemove) {
                                removed.add(Math.floor(Math.random() * 16));
                            }

                            const testPuzzle = this.solution.map(
                                (value, index) =>
                                    removed.has(index) ? 0 : value,
                            );

                            if (this.hasUniqueSolution(testPuzzle)) {
                                break;
                            }

                            attempts++;
                            if (attempts >= maxAttempts && cellsToRemove > 6) {
                                cellsToRemove--;
                                attempts = 0;
                            }
                        }

                        this.puzzle = this.solution.map((value, index) => ({
                            value: removed.has(index) ? "" : value,
                            fixed: !removed.has(index),
                            error: false,
                            correct: false,
                        }));
                    },

                    hasUniqueSolution(puzzle) {
                        const solutions = [];
                        this.solveSudoku([...puzzle], solutions, 2);
                        return solutions.length === 1;
                    },

                    solveSudoku(grid, solutions, maxSolutions) {
                        if (solutions.length >= maxSolutions) return;

                        const emptyIndex = grid.findIndex((cell) => cell === 0);
                        if (emptyIndex === -1) {
                            solutions.push([...grid]);
                            return;
                        }

                        const row = Math.floor(emptyIndex / 4);
                        const col = emptyIndex % 4;

                        for (let num = 1; num <= 4; num++) {
                            if (this.isValidMove(grid, row, col, num)) {
                                grid[emptyIndex] = num;
                                this.solveSudoku(grid, solutions, maxSolutions);
                                grid[emptyIndex] = 0;
                            }
                        }
                    },

                    isValidMove(grid, row, col, num) {
                        for (let c = 0; c < 4; c++) {
                            if (grid[row * 4 + c] === num) return false;
                        }

                        for (let r = 0; r < 4; r++) {
                            if (grid[r * 4 + col] === num) return false;
                        }

                        const boxRow = Math.floor(row / 2) * 2;
                        const boxCol = Math.floor(col / 2) * 2;
                        for (let r = boxRow; r < boxRow + 2; r++) {
                            for (let c = boxCol; c < boxCol + 2; c++) {
                                if (grid[r * 4 + c] === num) return false;
                            }
                        }

                        return true;
                    },

                    onlyNumbers(event) {
                        const char = event.key;
                        if (!/[1-4]/.test(char)) {
                            event.preventDefault();
                        }
                    },

                    recordOldValue(index) {
                        const cell = this.puzzle[index];
                        if (!cell.fixed) {
                            cell.oldValue = cell.value;
                        }
                    },

                    validateCell(index) {
                        const cell = this.puzzle[index];
                        const newValue = cell.value;
                        const oldValue =
                            cell.oldValue !== undefined ? cell.oldValue : "";

                        if (newValue !== oldValue && !cell.fixed) {
                            this.undoHistory.push({
                                index: index,
                                oldValue: oldValue,
                                newValue: newValue,
                            });
                        }

                        if (cell.value === "") {
                            cell.error = false;
                            cell.correct = false;
                            return;
                        }

                        const value = parseInt(cell.value);
                        if (isNaN(value) || value < 1 || value > 4) {
                            cell.value = "";
                            return;
                        }

                        const row = Math.floor(index / 4);
                        const col = index % 4;

                        let hasError = false;

                        for (let c = 0; c < 4; c++) {
                            const checkIndex = row * 4 + c;
                            if (
                                c !== col &&
                                this.puzzle[checkIndex].value == value
                            ) {
                                hasError = true;
                                break;
                            }
                        }

                        if (!hasError) {
                            for (let r = 0; r < 4; r++) {
                                const checkIndex = r * 4 + col;
                                if (
                                    r !== row &&
                                    this.puzzle[checkIndex].value == value
                                ) {
                                    hasError = true;
                                    break;
                                }
                            }
                        }

                        if (!hasError) {
                            const boxRow = Math.floor(row / 2) * 2;
                            const boxCol = Math.floor(col / 2) * 2;

                            for (let r = boxRow; r < boxRow + 2; r++) {
                                for (let c = boxCol; c < boxCol + 2; c++) {
                                    const checkIndex = r * 4 + c;
                                    if (
                                        checkIndex !== index &&
                                        this.puzzle[checkIndex].value == value
                                    ) {
                                        hasError = true;
                                        break;
                                    }
                                }
                                if (hasError) break;
                            }
                        }

                        cell.error = hasError;
                        cell.correct = !hasError && cell.value !== "";

                        if (this.isPuzzleComplete()) {
                            this.handleCompletion();
                        }
                    },

                    checkSolution() {
                        let allCorrect = true;

                        for (let i = 0; i < 16; i++) {
                            if (!this.puzzle[i].fixed) {
                                if (this.puzzle[i].value == this.solution[i]) {
                                    this.puzzle[i].correct = true;
                                    this.puzzle[i].error = false;
                                } else {
                                    this.puzzle[i].error = true;
                                    this.puzzle[i].correct = false;
                                    allCorrect = false;
                                }
                            }
                        }

                        if (allCorrect && this.isPuzzleComplete()) {
                            this.handleCompletion();
                        } else if (!this.isPuzzleComplete()) {
                            this.message = this.t.keepGoing;
                        } else {
                            this.message = this.t.someIncorrect;
                        }
                    },

                    isPuzzleComplete() {
                        return (
                            this.puzzle.every((cell) => cell.value !== "") &&
                            this.puzzle.every((cell) => !cell.error)
                        );
                    },
                },
            }).mount("#app");
        </script>
    </body>
</html>
