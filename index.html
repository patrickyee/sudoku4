<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>4x4 Sudoku</title>
        <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
        <style>
            body {
                font-family: Arial, sans-serif;
                display: flex;
                justify-content: center;
                align-items: center;
                min-height: 100vh;
                margin: 0;
                background-color: #f0f0f0;
                padding: 20px;
            }

            #app {
                text-align: center;
                width: 100%;
                max-width: 500px;
            }

            h1 {
                color: #333;
                font-size: 48px;
                margin: 20px 0;
            }

            .grid {
                display: inline-grid;
                grid-template-columns: repeat(4, 90px);
                gap: 0;
                margin: 30px 0;
                outline: 4px solid #333;
                width: fit-content;
            }

            .cell {
                width: 90px;
                height: 90px;
                background-color: white;
                border-top: 2px solid #ccc;
                border-left: 2px solid #ccc;
                font-size: 36px;
                text-align: center;
                box-sizing: border-box;
            }

            .cell:nth-child(n + 9):nth-child(-n + 12) {
                border-top: 4px solid #333;
            }

            .cell:nth-child(4n + 3) {
                border-left: 4px solid #333;
            }

            .cell input {
                width: 100%;
                height: 100%;
                border: none;
                text-align: center;
                font-size: 36px;
                outline: none;
            }

            .cell.fixed {
                background-color: #e8e8e8;
                font-weight: bold;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .cell.error input {
                background-color: #ffcccc;
            }

            .cell.correct input {
                background-color: #ccffcc;
            }

            button {
                padding: 16px 32px;
                font-size: 20px;
                background-color: #4caf50;
                color: white;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                margin: 10px;
                font-weight: bold;
            }

            button:hover {
                background-color: #45a049;
            }

            button:active {
                transform: scale(0.98);
            }

            button:disabled {
                background-color: #ccc;
                cursor: not-allowed;
                opacity: 0.6;
            }

            button:disabled:hover {
                background-color: #ccc;
            }

            .message {
                margin-top: 30px;
                font-size: 24px;
                font-weight: bold;
                min-height: 40px;
            }

            .message.success {
                color: #4caf50;
            }
        </style>
    </head>
    <body>
        <div id="app">
            <h1>4x4 Êï∏Áç®</h1>
            <div style="font-size: 28px; margin: 20px 0; font-weight: bold">
                <div>ÊôÇÈñìÔºö{{ formattedTime }}</div>
                <div
                    v-if="bestTime > 0"
                    style="color: #4caf50; margin-top: 10px"
                >
                    ÊúÄ‰Ω≥ÊôÇÈñìÔºö{{ formatTime(bestTime) }}
                </div>
            </div>
            <div class="grid">
                <div
                    v-for="(cell, index) in puzzle"
                    :key="index"
                    :class="getCellClass(cell)"
                >
                    <span v-if="cell.fixed">{{ cell.value }}</span>
                    <input
                        v-else
                        type="text"
                        maxlength="1"
                        v-model="cell.value"
                        @focus="recordOldValue(index)"
                        @input="validateCell(index)"
                        @keypress="onlyNumbers"
                    />
                </div>
            </div>
            <div>
                <button @click="newGame">Êñ∞ÈÅäÊà≤</button>
                <button @click="checkSolution">Ê™¢Êü•Á≠îÊ°à</button>
                <button @click="undo" :disabled="!canUndo">Âæ©Âéü</button>
            </div>
            <div style="margin-top: 20px; font-size: 20px">
                <label
                    style="
                        cursor: pointer;
                        display: inline-flex;
                        align-items: center;
                    "
                >
                    <input
                        type="checkbox"
                        v-model="showHints"
                        style="
                            width: 20px;
                            height: 20px;
                            margin-right: 10px;
                            cursor: pointer;
                        "
                    />
                    <span>È°ØÁ§∫ÊèêÁ§∫È°èËâ≤</span>
                </label>
            </div>
            <div class="message" :class="{ success: isComplete }">
                {{ message }}
            </div>
        </div>

        <script>
            const { createApp } = Vue;

            createApp({
                data() {
                    return {
                        puzzle: [],
                        solution: [],
                        message: "",
                        isComplete: false,
                        currentTime: 0,
                        timerInterval: null,
                        bestTime: 0,
                        undoHistory: [],
                        showHints: true,
                    };
                },
                computed: {
                    formattedTime() {
                        return this.formatTime(this.currentTime);
                    },
                    canUndo() {
                        return this.undoHistory.length > 0;
                    },
                },
                mounted() {
                    this.newGame();
                },
                beforeUnmount() {
                    if (this.timerInterval) {
                        clearInterval(this.timerInterval);
                    }
                },
                methods: {
                    getCellClass(cell) {
                        return {
                            cell: true,
                            fixed: cell.fixed,
                            error: this.showHints && cell.error,
                            correct: this.showHints && cell.correct,
                        };
                    },
                    formatTime(seconds) {
                        const mins = Math.floor(seconds / 60);
                        const secs = seconds % 60;
                        return `${mins}:${secs.toString().padStart(2, "0")}`;
                    },
                    startTimer() {
                        this.currentTime = 0;
                        if (this.timerInterval) {
                            clearInterval(this.timerInterval);
                        }
                        const startTime = Date.now();
                        this.timerInterval = setInterval(() => {
                            this.currentTime = Math.floor(
                                (Date.now() - startTime) / 1000,
                            );
                        }, 1000);
                    },
                    stopTimer() {
                        if (this.timerInterval) {
                            clearInterval(this.timerInterval);
                            this.timerInterval = null;
                        }
                    },
                    handleCompletion() {
                        this.stopTimer();
                        if (
                            this.bestTime === 0 ||
                            this.currentTime < this.bestTime
                        ) {
                            this.bestTime = this.currentTime;
                            this.message = "üéâ ÊÅ≠ÂñúÔºÅ‰Ω†ÊàêÂäüËß£Èñã‰∫ÜÔºÅÊñ∞Á¥ÄÈåÑÔºÅ";
                        } else {
                            this.message = "üéâ ÊÅ≠ÂñúÔºÅ‰Ω†ÊàêÂäüËß£Èñã‰∫ÜÔºÅ";
                        }
                        this.isComplete = true;
                    },
                    undo() {
                        if (this.undoHistory.length === 0) return;

                        const lastMove = this.undoHistory.pop();
                        this.puzzle[lastMove.index].value = lastMove.oldValue;
                        this.puzzle[lastMove.index].error = false;
                        this.puzzle[lastMove.index].correct = false;
                    },
                    newGame() {
                        this.message = "";
                        this.isComplete = false;
                        this.undoHistory = [];
                        this.generatePuzzle();
                        this.startTimer();
                    },

                    generatePuzzle() {
                        const solutions = [
                            [1, 2, 3, 4, 3, 4, 1, 2, 2, 3, 4, 1, 4, 1, 2, 3],
                            [2, 1, 4, 3, 4, 3, 2, 1, 1, 4, 3, 2, 3, 2, 1, 4],
                            [3, 4, 1, 2, 1, 2, 3, 4, 4, 3, 2, 1, 2, 1, 4, 3],
                            [4, 3, 2, 1, 2, 1, 4, 3, 3, 2, 1, 4, 1, 4, 3, 2],
                            [1, 3, 2, 4, 4, 2, 3, 1, 3, 1, 4, 2, 2, 4, 1, 3],
                            [2, 4, 1, 3, 3, 1, 4, 2, 4, 2, 3, 1, 1, 3, 2, 4],
                            [3, 2, 4, 1, 1, 4, 2, 3, 4, 3, 1, 2, 2, 1, 3, 4],
                            [4, 1, 3, 2, 2, 3, 1, 4, 1, 4, 2, 3, 3, 2, 4, 1],
                            [1, 4, 2, 3, 3, 2, 4, 1, 4, 1, 3, 2, 2, 3, 1, 4],
                            [2, 3, 4, 1, 4, 1, 2, 3, 1, 2, 3, 4, 3, 4, 1, 2],
                            [3, 1, 4, 2, 4, 2, 1, 3, 1, 3, 2, 4, 2, 4, 3, 1],
                            [4, 2, 1, 3, 1, 3, 2, 4, 2, 4, 3, 1, 3, 1, 4, 2],
                            [1, 3, 4, 2, 2, 4, 3, 1, 4, 1, 2, 3, 3, 2, 1, 4],
                            [2, 4, 3, 1, 3, 1, 2, 4, 1, 2, 4, 3, 4, 3, 1, 2],
                            [3, 1, 2, 4, 4, 2, 1, 3, 1, 4, 3, 2, 2, 3, 4, 1],
                            [4, 2, 1, 3, 1, 3, 4, 2, 3, 4, 2, 1, 2, 1, 3, 4],
                        ];

                        this.solution =
                            solutions[
                                Math.floor(Math.random() * solutions.length)
                            ];

                        let cellsToRemove = 8;
                        let removed = new Set();
                        let attempts = 0;
                        const maxAttempts = 20;

                        while (attempts < maxAttempts) {
                            removed = new Set();
                            while (removed.size < cellsToRemove) {
                                removed.add(Math.floor(Math.random() * 16));
                            }

                            const testPuzzle = this.solution.map(
                                (value, index) =>
                                    removed.has(index) ? 0 : value,
                            );

                            if (this.hasUniqueSolution(testPuzzle)) {
                                break;
                            }

                            attempts++;
                            if (attempts >= maxAttempts && cellsToRemove > 6) {
                                cellsToRemove--;
                                attempts = 0;
                            }
                        }

                        this.puzzle = this.solution.map((value, index) => ({
                            value: removed.has(index) ? "" : value,
                            fixed: !removed.has(index),
                            error: false,
                            correct: false,
                        }));
                    },

                    hasUniqueSolution(puzzle) {
                        const solutions = [];
                        this.solveSudoku([...puzzle], solutions, 2);
                        return solutions.length === 1;
                    },

                    solveSudoku(grid, solutions, maxSolutions) {
                        if (solutions.length >= maxSolutions) return;

                        const emptyIndex = grid.findIndex((cell) => cell === 0);
                        if (emptyIndex === -1) {
                            solutions.push([...grid]);
                            return;
                        }

                        const row = Math.floor(emptyIndex / 4);
                        const col = emptyIndex % 4;

                        for (let num = 1; num <= 4; num++) {
                            if (this.isValidMove(grid, row, col, num)) {
                                grid[emptyIndex] = num;
                                this.solveSudoku(grid, solutions, maxSolutions);
                                grid[emptyIndex] = 0;
                            }
                        }
                    },

                    isValidMove(grid, row, col, num) {
                        for (let c = 0; c < 4; c++) {
                            if (grid[row * 4 + c] === num) return false;
                        }

                        for (let r = 0; r < 4; r++) {
                            if (grid[r * 4 + col] === num) return false;
                        }

                        const boxRow = Math.floor(row / 2) * 2;
                        const boxCol = Math.floor(col / 2) * 2;
                        for (let r = boxRow; r < boxRow + 2; r++) {
                            for (let c = boxCol; c < boxCol + 2; c++) {
                                if (grid[r * 4 + c] === num) return false;
                            }
                        }

                        return true;
                    },

                    onlyNumbers(event) {
                        const char = event.key;
                        if (!/[1-4]/.test(char)) {
                            event.preventDefault();
                        }
                    },

                    recordOldValue(index) {
                        const cell = this.puzzle[index];
                        if (!cell.fixed) {
                            cell.oldValue = cell.value;
                        }
                    },

                    validateCell(index) {
                        const cell = this.puzzle[index];
                        const newValue = cell.value;
                        const oldValue =
                            cell.oldValue !== undefined ? cell.oldValue : "";

                        if (newValue !== oldValue && !cell.fixed) {
                            this.undoHistory.push({
                                index: index,
                                oldValue: oldValue,
                                newValue: newValue,
                            });
                        }

                        if (cell.value === "") {
                            cell.error = false;
                            cell.correct = false;
                            return;
                        }

                        const value = parseInt(cell.value);
                        if (isNaN(value) || value < 1 || value > 4) {
                            cell.value = "";
                            return;
                        }

                        const row = Math.floor(index / 4);
                        const col = index % 4;

                        let hasError = false;

                        for (let c = 0; c < 4; c++) {
                            const checkIndex = row * 4 + c;
                            if (
                                c !== col &&
                                this.puzzle[checkIndex].value == value
                            ) {
                                hasError = true;
                                break;
                            }
                        }

                        if (!hasError) {
                            for (let r = 0; r < 4; r++) {
                                const checkIndex = r * 4 + col;
                                if (
                                    r !== row &&
                                    this.puzzle[checkIndex].value == value
                                ) {
                                    hasError = true;
                                    break;
                                }
                            }
                        }

                        if (!hasError) {
                            const boxRow = Math.floor(row / 2) * 2;
                            const boxCol = Math.floor(col / 2) * 2;

                            for (let r = boxRow; r < boxRow + 2; r++) {
                                for (let c = boxCol; c < boxCol + 2; c++) {
                                    const checkIndex = r * 4 + c;
                                    if (
                                        checkIndex !== index &&
                                        this.puzzle[checkIndex].value == value
                                    ) {
                                        hasError = true;
                                        break;
                                    }
                                }
                                if (hasError) break;
                            }
                        }

                        cell.error = hasError;
                        cell.correct = !hasError && cell.value !== "";

                        if (this.isPuzzleComplete()) {
                            this.handleCompletion();
                        }
                    },

                    checkSolution() {
                        let allCorrect = true;

                        for (let i = 0; i < 16; i++) {
                            if (!this.puzzle[i].fixed) {
                                if (this.puzzle[i].value == this.solution[i]) {
                                    this.puzzle[i].correct = true;
                                    this.puzzle[i].error = false;
                                } else {
                                    this.puzzle[i].error = true;
                                    this.puzzle[i].correct = false;
                                    allCorrect = false;
                                }
                            }
                        }

                        if (allCorrect && this.isPuzzleComplete()) {
                            this.handleCompletion();
                        } else if (!this.isPuzzleComplete()) {
                            this.message = "ÁπºÁ∫åÂä™ÂäõÔºÅË´ãÂ°´ÊªøÊâÄÊúâÊ†ºÂ≠ê„ÄÇ";
                        } else {
                            this.message = "Êúâ‰∫õÊ†ºÂ≠ê‰∏çÊ≠£Á¢∫ÔºåÂÜçË©¶Ë©¶ÁúãÔºÅ";
                        }
                    },

                    isPuzzleComplete() {
                        return (
                            this.puzzle.every((cell) => cell.value !== "") &&
                            this.puzzle.every((cell) => !cell.error)
                        );
                    },
                },
            }).mount("#app");
        </script>
    </body>
</html>
